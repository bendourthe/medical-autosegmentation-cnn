####################
# LIBRARIES IMPORT #
####################

import torch
import torch.nn as nn
import torch.nn.functional as F

####################
# CLASS DEFINITION #
####################

#----------------------------------------------------------------------------------------------------#
class MultiClassDiceLoss(nn.Module):
    
    def __init__(self, num_labels, input_shape=256):
        '''
        DOURTHE TECHNOLOGIES - CONFIDENTIAL
	    Unpublished Copyright Â© 2022 Dourthe Technologies (dourthetechnologies.com)

	    Created on: Tue Apr 12 2022 
	    Author: Benjamin Dourthe (benjamin@dourthe.tech)

	    Description:
	    ------------

            Multiclass adaptation of the average Dice loss originally presented by Milletari et al. (2016).
            	Milletari F, Navab N, Ahmadi SA. V-Net: Fully Convolutional Neural Networks
	            for Volumetric Medical Image Segmentation.
	            arXiv:1606.04797v1, 2016 (https://arxiv.org/abs/1606.04797)

	    Parameters:
	    -----------

	    	num_labels: specifies number of labels
            	(type: integer)
            input_shape: specifies shape of input image (e.g. input_shape=128 for input images of size 128x128)
                (type: integer) (default=256)
        '''
        
        super().__init__()

        self.num_labels = num_labels
        self.input_shape = input_shape
        
    def forward(self, stage1_output, stage2_output, target, device):
        '''
        Parameters:
        -----------

            stage1_output: output generated by the 1st stage of the multi-scale pyramid 3D FCN
            stage2_output: output generated by the 2nd stage of the multi-scale pyramid 3D FCN
            target: expected labels
            device: defined device ('cuda' or 'cpu')
        '''
        
        # GROUND TRUTH
        #   Initialization
        label_target = torch.zeros((target.size(0), self.num_labels, self.input_shape, self.input_shape))
        #   Adapt ground truth target shape to model output
        for label in range(1, self.num_labels+1):
            temp_target = torch.zeros(target.size())
            temp_target[target==label] = 1
            label_target[:, label-1, :, :] = temp_target
        label_target = label_target.to(device)
            
        # STAGE 1 LOSS
        #   Initialization
        stage1_loss = 0
        #   Calculate and sum dice losses for each label
        for label in range(1, self.num_labels+1):
            numerator = 2*(stage1_output[:, label, :, :]*label_target[:, label-1, :, :]).sum(dim=1).sum(dim=1)
            denominator = (stage1_output[:, label, :, :]**2).sum(dim=1).sum(dim=1) + (label_target[:, label-1, :, :]**2).sum(dim=1).sum(dim=1) + 1*10**-5 
            stage1_loss += numerator / denominator
        #   Calculate average dice loss for all labels
        stage1_loss /= self.num_labels
        
        # STAGE 2 LOSS
        #   Initialization
        stage2_loss = 0
        #   Calculate and sum dice losses for each label
        for label in range(1, self.num_labels+1):
            numerator = 2*(stage2_output[:, label, :, :]*label_target[:, label-1, :, :]).sum(dim=1).sum(dim=1)
            denominator = (stage2_output[:, label, :, :]**2).sum(dim=1).sum(dim=1) + (label_target[:, label-1, :, :]**2).sum(dim=1).sum(dim=1) + 1*10**-5 
            stage2_loss += numerator / denominator
        #   Calculate average dice loss for all labels
        stage2_loss /= self.num_labels
        
        # TOTAL LOSS
        loss = stage1_loss + stage2_loss
        
        # RETURN DICE DISTANCE
        return (2-loss).mean()